

Exo 1: MI 1
	ligne 18 << 0
	ligne 20 << 1
	ligne 22 << 1 #et non 5, car la variable à la même nom que l'attribut de classe, et cache donc cet attribut. Pour avoir 5, il faudrais écrire : ligne 11: this.a = a;


Exo 2: MI 2
	Error ligne 18: fonction non déclarée #on voudrais plutôt appeler; obj.methode();
	#!! à noter que la ligne 11 ne créé pas d'erreur, car methode() étant appelée dans la classe, elle est implicitement this.methode()

Exo3: MI 5
	<< 2M\n1M
	# comme méthode1() est un appel ambigu entre methode1() et A.methode1(), le prog choisi celle de la classe par défaut


Exo4: MI 3
	ligne 17 << 2M\n1F
	#la ligne 9 permet de forcer l'appel de methode1() extern à la ligne 11
	# on peut écrire; ::methode3()#ligne 11 (sans la ligne 9)



Exo5: PPI 1
	Ne compile pas (ERROR ligne 7). Tentative d'accès à un membre privé


Exo6: PPI 3
	Compile.


Exo7: PPI 4
	Ne compile pas (ERROR ligne 6) car membre privé
	#!! quand on ne mentionne pas private/public, par défaut, c'est privé dans une classe


Exo8: PPI 2.1
	Compile. Le constructeur est implicitement construit (par défaut) et public


Exo9: PPI 2.2
	Ne compile pas (ERROR ligne 7). On déclare, donc appel au constructeur, mais qui est privé, donc ne compile pas	


Exo10: SI 3
	Ne compile pas (ERROR ligne 3), car les signatures (nom et type des variables) de f() sont identiques


Exo11: SI 1
	#!! ligne 9, c'est 1L, pas 11 #c'est pour dire que le 1 est un long (n'est pas un cast)
	ligne 8  << f3
	ligne 9  << f2
	ligne 10 << f4 #la conversion long->char est char->long est possible
	ligne 11 << f1


Exo12: SI 2
	Ne compile pas (ERROR ligne 6) car les signatures ne correspondent pas exactement à l'appel, et les deux conversion implicite dégrade la valeur


Exo18: SI 4
	A a;       //"Je suis A()"
	A a{5};    //"Je suis A(int) avec 5"
	A a = {3}; //"Je suis A(int) avec 3"
	A d(2);    //"Je suis A(int) avec 2"
	A e();     //rien !! déclaration d'une fonction

Exo19: CDI 2
	Construction
	Destruction

Exo20: CDI 4
	affiche rien, car ligne 10 est une déclaration d'une fonction retournant un objet A

Exo21: CDI 3
	C0
	C1
	C2
	C3
	D3
	D2
	C4
	D4
	D1
	D0

Exo22: CDI 1
	aucun constructeur correspondant à A(void)


Exo23: CDI5
	A1
	A1
	A2
	A3
	A3
	//error, ambigu



Exo24: NDI 1
	C5
	C1
	D5
	D1



Exo25: NDI 6
	// rien, juste de la réservation de mémoire


Exo26: NDI 2
	C5
	C1
	D1
	//attention, mémoire non libérée (donc constructeur de A n'est pas appelé)

Exo27: NDI3
	C2
	C4
	//A{2} a été écrasé par A{4} (pas de fuite de mémoire)
	D4

Exo28: NDI4

	17 >> "Bonjour"
	18 >> "Bonjour"
	19 >> rien (car juste déclaration d'un pointeur)
	21 >> "Bonjour"
	22 >> "Au revoir" D de 2
	23 >> "Bonjour" 
	24 >> "Au revoir" D de 4
	25 >> "Bonjour"
	26 >> "Au revoir" "Au revoir" //D de 5 et D de ob
	//attention obj2 n'a pas été libéré


Exo29: NDI5
	//attention si A() alloue de la mémoire dans son code, il faut penser à libérer les objet
	//attention il vaut mieux appeler explicitement les destructeurs dans cet exemple (plutot que "delete")


